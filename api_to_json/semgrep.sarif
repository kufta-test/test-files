{
  "$schema": "https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/schemas/sarif-schema-2.1.0.json",
  "runs": [
    {
      "invocations": [
        {
          "executionSuccessful": true,
          "toolExecutionNotifications": []
        }
      ],
      "results": [
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 38,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 30
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:28 to go/gorilla-command-injection-taint.go:33"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 28,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 28,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:33'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 33,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:33'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 33
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 33,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:28 to go/gorilla-command-injection-taint.go:50"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 28,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 28,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:47'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 14,
                            "endLine": 47,
                            "message": {
                              "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:47'"
                            },
                            "snippet": {
                              "text": "cmd3Input"
                            },
                            "startColumn": 5,
                            "startLine": 47
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))' @ 'go/gorilla-command-injection-taint.go:50'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 47,
                            "endLine": 50,
                            "message": {
                              "text": "Sink: 'cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))' @ 'go/gorilla-command-injection-taint.go:50'"
                            },
                            "snippet": {
                              "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                            },
                            "startColumn": 5,
                            "startLine": 50
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 47,
                  "endLine": 50,
                  "snippet": {
                    "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                  },
                  "startColumn": 5,
                  "startLine": 50
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "99658f66523f5b02f679015129ec49e7c675568bb3c4fa29dd5bd9c21e9307a7b8254d3e3606e11b8a6231e2a64fb38f5bef45390f720c949c8a236e42a27cab_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 47,
                  "endLine": 50,
                  "snippet": {
                    "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                  },
                  "startColumn": 5,
                  "startLine": 50
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside Write. Audit the input to 'cmd3Writer.Write'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-command-write.dangerous-command-write"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:28 to go/gorilla-command-injection-taint.go:53"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 28,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 28,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:28'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 28
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:47'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 14,
                            "endLine": 47,
                            "message": {
                              "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:47'"
                            },
                            "snippet": {
                              "text": "cmd3Input"
                            },
                            "startColumn": 5,
                            "startLine": 47
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'io.WriteString(cmd3Writer, cmd3Input)' @ 'go/gorilla-command-injection-taint.go:53'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 41,
                            "endLine": 53,
                            "message": {
                              "text": "Sink: 'io.WriteString(cmd3Writer, cmd3Input)' @ 'go/gorilla-command-injection-taint.go:53'"
                            },
                            "snippet": {
                              "text": "    io.WriteString(cmd3Writer, cmd3Input)"
                            },
                            "startColumn": 32,
                            "startLine": 53
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 41,
                  "endLine": 53,
                  "snippet": {
                    "text": "    io.WriteString(cmd3Writer, cmd3Input)"
                  },
                  "startColumn": 32,
                  "startLine": 53
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "8dca8164af7906b03561afb317771ea36b6cf067ad4d4c87052a5499359d2506326c0141cfd7782d67e959b29f35b482f96b86af40819ae6bf1df0268ad0d141_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 38,
                  "endLine": 57,
                  "snippet": {
                    "text": "    syscall.Exec(\"echo \" + cmd4Input)"
                  },
                  "startColumn": 5,
                  "startLine": 57
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "4d993d35de97caaadae8e34fbce1b44a8fe9f4bb2d10b53cf07c4dc2b7a9b7579e6d7441df953024d07c24e7d3b7b587ce2f585849d274b0f6f0e43f9ed2ec10_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 82,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: person.Name,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 74
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:77 to go/gorilla-command-injection-taint.go:77"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'person' @ 'go/gorilla-command-injection-taint.go:77'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 21,
                            "endLine": 77,
                            "message": {
                              "text": "Source: 'person' @ 'go/gorilla-command-injection-taint.go:77'"
                            },
                            "snippet": {
                              "text": "person"
                            },
                            "startColumn": 15,
                            "startLine": 77
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: person.Name,' @ 'go/gorilla-command-injection-taint.go:77'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 26,
                            "endLine": 77,
                            "message": {
                              "text": "Sink: 'Path: person.Name,' @ 'go/gorilla-command-injection-taint.go:77'"
                            },
                            "snippet": {
                              "text": "        Path: person.Name,"
                            },
                            "startColumn": 15,
                            "startLine": 77
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_3"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 26,
                  "endLine": 77,
                  "snippet": {
                    "text": "        Path: person.Name,"
                  },
                  "startColumn": 15,
                  "startLine": 77
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d0bf327480d2c53052476adcfa181c629c8257a55d92fb6667e64098bf42bec9b294aa58e09edfecee5bec5cb12044ccf3b557268609cee01680b0a3566cce11_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 14,
                  "endLine": 113,
                  "snippet": {
                    "text": "            cmd := &exec.Cmd {\n                // Path is the path of the command to run.\n                // ruleid: gorilla-command-injection-taint\n                Path: value[\"foo\"],\n                // Args holds command line arguments, including the command as Args[0].\n                Args: []string{ \"tr\", \"--help\" },\n                Stdout: os.Stdout,\n                Stderr: os.Stderr,\n            }"
                  },
                  "startColumn": 21,
                  "startLine": 105
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:108 to go/gorilla-command-injection-taint.go:108"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:108'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 108,
                            "message": {
                              "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:108'"
                            },
                            "snippet": {
                              "text": "value"
                            },
                            "startColumn": 23,
                            "startLine": 108
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:108'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 35,
                            "endLine": 108,
                            "message": {
                              "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:108'"
                            },
                            "snippet": {
                              "text": "                Path: value[\"foo\"],"
                            },
                            "startColumn": 23,
                            "startLine": 108
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_4"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 35,
                  "endLine": 108,
                  "snippet": {
                    "text": "                Path: value[\"foo\"],"
                  },
                  "startColumn": 23,
                  "startLine": 108
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d0bf327480d2c53052476adcfa181c629c8257a55d92fb6667e64098bf42bec9b294aa58e09edfecee5bec5cb12044ccf3b557268609cee01680b0a3566cce11_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 10,
                  "endLine": 139,
                  "snippet": {
                    "text": "        cmd := &exec.Cmd {\n            // Path is the path of the command to run.\n            // ruleid: gorilla-command-injection-taint\n            Path: value[\"foo\"],\n            // Args holds command line arguments, including the command as Args[0].\n            Args: []string{ \"tr\", \"--help\" },\n            Stdout: os.Stdout,\n            Stderr: os.Stderr,\n        }"
                  },
                  "startColumn": 17,
                  "startLine": 131
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:134 to go/gorilla-command-injection-taint.go:134"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:134'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 24,
                            "endLine": 134,
                            "message": {
                              "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:134'"
                            },
                            "snippet": {
                              "text": "value"
                            },
                            "startColumn": 19,
                            "startLine": 134
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:134'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 31,
                            "endLine": 134,
                            "message": {
                              "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:134'"
                            },
                            "snippet": {
                              "text": "            Path: value[\"foo\"],"
                            },
                            "startColumn": 19,
                            "startLine": 134
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_5"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 31,
                  "endLine": 134,
                  "snippet": {
                    "text": "            Path: value[\"foo\"],"
                  },
                  "startColumn": 19,
                  "startLine": 134
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "bb9e5897046561f4e0a2d4547275a47a64cfd8d286982b851c97c76575da12a7317ff29f7d1057db7b4c4bb0a5c5e8f22a4d6382a0d06d2f8f9faca01e336a91_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 45,
                  "endLine": 154,
                  "snippet": {
                    "text": "    conn, err := upgrader.Upgrade(w, r, nil)"
                  },
                  "startColumn": 18,
                  "startLine": 154
                }
              }
            }
          ],
          "message": {
            "text": "The Origin header in the HTTP WebSocket handshake is used to guarantee that the connection accepted by the WebSocket is from a trusted origin domain. Failure to enforce can lead to Cross Site Request Forgery (CSRF). As per \"gorilla/websocket\" documentation: \"A CheckOrigin function should carefully validate the request origin to prevent cross-site request forgery.\""
          },
          "properties": {},
          "ruleId": "go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 166,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 158
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:155 to go/gorilla-command-injection-taint.go:161"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 155,
                            "message": {
                              "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 155
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 155,
                            "message": {
                              "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 155
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:156'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 156,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:156'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 156
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:161'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 161,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:161'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 161
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_6"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 161,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 161
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 184,
                  "snippet": {
                    "text": "    cmd = &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 12,
                  "startLine": 176
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:155 to go/gorilla-command-injection-taint.go:179"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 155,
                            "message": {
                              "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 155
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 155,
                            "message": {
                              "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:155'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 155
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:156'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 156,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:156'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 156
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:179'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 179,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:179'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 179
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_7"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 179,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 179
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_3"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 213,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 205
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:203 to go/gorilla-command-injection-taint.go:208"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 203,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 203,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:208'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 208,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:208'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 208
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_8"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 208,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 208
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:203 to go/gorilla-command-injection-taint.go:225"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 203,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 203,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:222'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 14,
                            "endLine": 222,
                            "message": {
                              "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:222'"
                            },
                            "snippet": {
                              "text": "cmd3Input"
                            },
                            "startColumn": 5,
                            "startLine": 222
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))' @ 'go/gorilla-command-injection-taint.go:225'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 47,
                            "endLine": 225,
                            "message": {
                              "text": "Sink: 'cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))' @ 'go/gorilla-command-injection-taint.go:225'"
                            },
                            "snippet": {
                              "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                            },
                            "startColumn": 5,
                            "startLine": 225
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_9"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 47,
                  "endLine": 225,
                  "snippet": {
                    "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                  },
                  "startColumn": 5,
                  "startLine": 225
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "99658f66523f5b02f679015129ec49e7c675568bb3c4fa29dd5bd9c21e9307a7b8254d3e3606e11b8a6231e2a64fb38f5bef45390f720c949c8a236e42a27cab_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 47,
                  "endLine": 225,
                  "snippet": {
                    "text": "    cmd3Writer.Write([]byte(cmd3Input + \"\\n\"))"
                  },
                  "startColumn": 5,
                  "startLine": 225
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside Write. Audit the input to 'cmd3Writer.Write'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-command-write.dangerous-command-write"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:203 to go/gorilla-command-injection-taint.go:228"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 203,
                            "message": {
                              "text": "Source: 'session.Values' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "session.Values"
                            },
                            "startColumn": 14,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 203,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:203'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 203
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:222'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 14,
                            "endLine": 222,
                            "message": {
                              "text": "Propagator : 'cmd3Input' @ 'go/gorilla-command-injection-taint.go:222'"
                            },
                            "snippet": {
                              "text": "cmd3Input"
                            },
                            "startColumn": 5,
                            "startLine": 222
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'io.WriteString(cmd3Writer, cmd3Input)' @ 'go/gorilla-command-injection-taint.go:228'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 41,
                            "endLine": 228,
                            "message": {
                              "text": "Sink: 'io.WriteString(cmd3Writer, cmd3Input)' @ 'go/gorilla-command-injection-taint.go:228'"
                            },
                            "snippet": {
                              "text": "    io.WriteString(cmd3Writer, cmd3Input)"
                            },
                            "startColumn": 32,
                            "startLine": 228
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_10"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 41,
                  "endLine": 228,
                  "snippet": {
                    "text": "    io.WriteString(cmd3Writer, cmd3Input)"
                  },
                  "startColumn": 32,
                  "startLine": 228
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "8dca8164af7906b03561afb317771ea36b6cf067ad4d4c87052a5499359d2506326c0141cfd7782d67e959b29f35b482f96b86af40819ae6bf1df0268ad0d141_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 38,
                  "endLine": 232,
                  "snippet": {
                    "text": "    syscall.Exec(\"echo \" + cmd4Input)"
                  },
                  "startColumn": 5,
                  "startLine": 232
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "4d993d35de97caaadae8e34fbce1b44a8fe9f4bb2d10b53cf07c4dc2b7a9b7579e6d7441df953024d07c24e7d3b7b587ce2f585849d274b0f6f0e43f9ed2ec10_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 257,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: person.Name,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 249
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:252 to go/gorilla-command-injection-taint.go:252"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'person' @ 'go/gorilla-command-injection-taint.go:252'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 21,
                            "endLine": 252,
                            "message": {
                              "text": "Source: 'person' @ 'go/gorilla-command-injection-taint.go:252'"
                            },
                            "snippet": {
                              "text": "person"
                            },
                            "startColumn": 15,
                            "startLine": 252
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: person.Name,' @ 'go/gorilla-command-injection-taint.go:252'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 26,
                            "endLine": 252,
                            "message": {
                              "text": "Sink: 'Path: person.Name,' @ 'go/gorilla-command-injection-taint.go:252'"
                            },
                            "snippet": {
                              "text": "        Path: person.Name,"
                            },
                            "startColumn": 15,
                            "startLine": 252
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_11"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 26,
                  "endLine": 252,
                  "snippet": {
                    "text": "        Path: person.Name,"
                  },
                  "startColumn": 15,
                  "startLine": 252
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d0bf327480d2c53052476adcfa181c629c8257a55d92fb6667e64098bf42bec9b294aa58e09edfecee5bec5cb12044ccf3b557268609cee01680b0a3566cce11_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 14,
                  "endLine": 288,
                  "snippet": {
                    "text": "            cmd := &exec.Cmd {\n                // Path is the path of the command to run.\n                // ruleid: gorilla-command-injection-taint\n                Path: value[\"foo\"],\n                // Args holds command line arguments, including the command as Args[0].\n                Args: []string{ \"tr\", \"--help\" },\n                Stdout: os.Stdout,\n                Stderr: os.Stderr,\n            }"
                  },
                  "startColumn": 21,
                  "startLine": 280
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:283 to go/gorilla-command-injection-taint.go:283"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:283'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 283,
                            "message": {
                              "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:283'"
                            },
                            "snippet": {
                              "text": "value"
                            },
                            "startColumn": 23,
                            "startLine": 283
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:283'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 35,
                            "endLine": 283,
                            "message": {
                              "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:283'"
                            },
                            "snippet": {
                              "text": "                Path: value[\"foo\"],"
                            },
                            "startColumn": 23,
                            "startLine": 283
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_12"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 35,
                  "endLine": 283,
                  "snippet": {
                    "text": "                Path: value[\"foo\"],"
                  },
                  "startColumn": 23,
                  "startLine": 283
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d0bf327480d2c53052476adcfa181c629c8257a55d92fb6667e64098bf42bec9b294aa58e09edfecee5bec5cb12044ccf3b557268609cee01680b0a3566cce11_3"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 10,
                  "endLine": 314,
                  "snippet": {
                    "text": "        cmd := &exec.Cmd {\n            // Path is the path of the command to run.\n            // ruleid: gorilla-command-injection-taint\n            Path: value[\"foo\"],\n            // Args holds command line arguments, including the command as Args[0].\n            Args: []string{ \"tr\", \"--help\" },\n            Stdout: os.Stdout,\n            Stderr: os.Stderr,\n        }"
                  },
                  "startColumn": 17,
                  "startLine": 306
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:309 to go/gorilla-command-injection-taint.go:309"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:309'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 24,
                            "endLine": 309,
                            "message": {
                              "text": "Source: 'value' @ 'go/gorilla-command-injection-taint.go:309'"
                            },
                            "snippet": {
                              "text": "value"
                            },
                            "startColumn": 19,
                            "startLine": 309
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:309'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 31,
                            "endLine": 309,
                            "message": {
                              "text": "Sink: 'Path: value[\"foo\"],' @ 'go/gorilla-command-injection-taint.go:309'"
                            },
                            "snippet": {
                              "text": "            Path: value[\"foo\"],"
                            },
                            "startColumn": 19,
                            "startLine": 309
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_13"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 31,
                  "endLine": 309,
                  "snippet": {
                    "text": "            Path: value[\"foo\"],"
                  },
                  "startColumn": 19,
                  "startLine": 309
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "bb9e5897046561f4e0a2d4547275a47a64cfd8d286982b851c97c76575da12a7317ff29f7d1057db7b4c4bb0a5c5e8f22a4d6382a0d06d2f8f9faca01e336a91_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 45,
                  "endLine": 329,
                  "snippet": {
                    "text": "    conn, err := upgrader.Upgrade(w, r, nil)"
                  },
                  "startColumn": 18,
                  "startLine": 329
                }
              }
            }
          ],
          "message": {
            "text": "The Origin header in the HTTP WebSocket handshake is used to guarantee that the connection accepted by the WebSocket is from a trusted origin domain. Failure to enforce can lead to Cross Site Request Forgery (CSRF). As per \"gorilla/websocket\" documentation: \"A CheckOrigin function should carefully validate the request origin to prevent cross-site request forgery.\""
          },
          "properties": {},
          "ruleId": "go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_4"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 341,
                  "snippet": {
                    "text": "    cmd := &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 13,
                  "startLine": 333
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:330 to go/gorilla-command-injection-taint.go:336"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 330,
                            "message": {
                              "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 330
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 330,
                            "message": {
                              "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 330
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:331'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 331,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:331'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 331
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:336'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 336,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:336'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 336
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_14"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 336,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 336
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "cc96ed0a6b16e0b3647cf39b4bbad0561b75ef95f119bc2142bae728f5e9080e0d5166bb25a1448d45554d07e95da08cab1f5aa9079d0f719df69c618e54be46_5"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 6,
                  "endLine": 359,
                  "snippet": {
                    "text": "    cmd = &exec.Cmd {\n        // Path is the path of the command to run.\n        // ruleid: gorilla-command-injection-taint\n        Path: email,\n        // Args holds command line arguments, including the command as Args[0].\n        Args: []string{ \"tr\", \"--help\" },\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }"
                  },
                  "startColumn": 12,
                  "startLine": 351
                }
              }
            }
          ],
          "message": {
            "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-command-injection-taint.go:330 to go/gorilla-command-injection-taint.go:354"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 330,
                            "message": {
                              "text": "Source: 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 330
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 19,
                            "endLine": 330,
                            "message": {
                              "text": "Propagator : 'p' @ 'go/gorilla-command-injection-taint.go:330'"
                            },
                            "snippet": {
                              "text": "p"
                            },
                            "startColumn": 18,
                            "startLine": 330
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:331'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 10,
                            "endLine": 331,
                            "message": {
                              "text": "Propagator : 'email' @ 'go/gorilla-command-injection-taint.go:331'"
                            },
                            "snippet": {
                              "text": "email"
                            },
                            "startColumn": 5,
                            "startLine": 331
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:354'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-command-injection-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 354,
                            "message": {
                              "text": "Sink: 'Path: email,' @ 'go/gorilla-command-injection-taint.go:354'"
                            },
                            "snippet": {
                              "text": "        Path: email,"
                            },
                            "startColumn": 15,
                            "startLine": 354
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "545a0c19c52f044882a41d3ee9a3b50b878e3e7598d4fe165e6bbbba58559f10542491ffb326316ccbe58c6420c37b3ac7b8d4e2227be5567976f921858ad7ea_15"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-command-injection-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 354,
                  "snippet": {
                    "text": "        Path: email,"
                  },
                  "startColumn": 15,
                  "startLine": 354
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
          },
          "properties": {},
          "ruleId": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "8028a55826aec7f701942e6976eaea85908b9ec578b4e71cdc54dc10a2b1c743314e4136fb1e5738a49ed278c0c7e184adbb5974713c62800e4ac5994f7f3244_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 59,
                  "endLine": 31,
                  "snippet": {
                    "text": "    query := \"SELECT name FROM users WHERE email=\" + email"
                  },
                  "startColumn": 5,
                  "startLine": 31
                }
              }
            }
          ],
          "message": {
            "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.database.string-formatted-query.string-formatted-query"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d7e6c56c89a0008dd38196f7451d60decea3352dc8309cd58d2ad1dd6b66006533699e20e0957d4beca941e1d225589dd8b355e5762ce241f4b0601b5f40cc05_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 17,
                  "endLine": 33,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 2,
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:33"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 34,
                            "endLine": 37,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:33'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 33,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:33'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 33
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0a964f0a6bfe9b8cb134fab8040e946e84705bd6d838e58ac525fc85a854dba6ecec1f1c36064ea113b89ee9a190e884661c42dc040ac8b741a685da63cc6653_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 33,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:33"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 34,
                            "endLine": 37,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:33'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 33,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:33'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 33
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a76f0507f5ad1fa2895cc324641352fe24fee68060ee39101409d5bab19ad8a8d596e1ee59e69f7579f191af64a91b0d9c9491373b0dd3302156e653e0a317e9_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 33,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 33
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "a764c0cd0b86447424b5bc627494646ddf7e79d68ca678d6e8c2c9675301e6459e563ef42da31981517b5e42f0b21b54cc5df0eea834cb6f45fb0ad806628ab5_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 60,
                  "endLine": 49,
                  "snippet": {
                    "text": "\tquery := \"SELECT name FROM users WHERE age=\" + person.Name"
                  },
                  "startColumn": 2,
                  "startLine": 49
                }
              }
            }
          ],
          "message": {
            "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.database.string-formatted-query.string-formatted-query"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "6a1600c6a6e99a37ac22338557affd67941d14dac844bcb740a4b4d9a1a0a6a7e787f67f1ebf24dbafc93a801d3734d5a912c5373dadf4f9ed38da3a9ffdcf46_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 17,
                  "endLine": 52,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 2,
                  "startLine": 52
                }
              }
            }
          ],
          "message": {
            "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:52"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:52'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 52,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:52'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 52
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0a964f0a6bfe9b8cb134fab8040e946e84705bd6d838e58ac525fc85a854dba6ecec1f1c36064ea113b89ee9a190e884661c42dc040ac8b741a685da63cc6653_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 52,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 52
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:52"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:52'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 52,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:52'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 52
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a76f0507f5ad1fa2895cc324641352fe24fee68060ee39101409d5bab19ad8a8d596e1ee59e69f7579f191af64a91b0d9c9491373b0dd3302156e653e0a317e9_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 52,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 52
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "3e606dcb30944430817a521f1c062e2b9635fb5fb404506bf6ce4997ad7d9adbbd56cf68c658cd846a0d6fa2b1bb9a5df5c039a14b8505cfc6ae30f38068c7bf_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 70,
                  "endLine": 73,
                  "snippet": {
                    "text": "        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]"
                  },
                  "startColumn": 9,
                  "startLine": 73
                }
              }
            }
          ],
          "message": {
            "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.database.string-formatted-query.string-formatted-query"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "839b5ec280fec6b89bf4944598841f78808beb00a555913f66a5e38bbaaa480f2061713c937f144e30942efd40119572632b383e6f3dd065e0724cfc740033bf_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 21,
                  "endLine": 75,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 6,
                  "startLine": 75
                }
              }
            }
          ],
          "message": {
            "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:75"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:75'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 75,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:75'"
                            },
                            "snippet": {
                              "text": "\t    db.Query(query)"
                            },
                            "startColumn": 15,
                            "startLine": 75
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0a964f0a6bfe9b8cb134fab8040e946e84705bd6d838e58ac525fc85a854dba6ecec1f1c36064ea113b89ee9a190e884661c42dc040ac8b741a685da63cc6653_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 75,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 15,
                  "startLine": 75
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:75"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:75'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 75,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:75'"
                            },
                            "snippet": {
                              "text": "\t    db.Query(query)"
                            },
                            "startColumn": 15,
                            "startLine": 75
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a76f0507f5ad1fa2895cc324641352fe24fee68060ee39101409d5bab19ad8a8d596e1ee59e69f7579f191af64a91b0d9c9491373b0dd3302156e653e0a317e9_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 75,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 15,
                  "startLine": 75
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "839b5ec280fec6b89bf4944598841f78808beb00a555913f66a5e38bbaaa480f2061713c937f144e30942efd40119572632b383e6f3dd065e0724cfc740033bf_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 21,
                  "endLine": 92,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 6,
                  "startLine": 92
                }
              }
            }
          ],
          "message": {
            "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:92"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:92'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 92,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:92'"
                            },
                            "snippet": {
                              "text": "\t    db.Query(query)"
                            },
                            "startColumn": 15,
                            "startLine": 92
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0a964f0a6bfe9b8cb134fab8040e946e84705bd6d838e58ac525fc85a854dba6ecec1f1c36064ea113b89ee9a190e884661c42dc040ac8b741a685da63cc6653_3"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 92,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 15,
                  "startLine": 92
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:92"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 70,
                            "endLine": 99,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:92'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 20,
                            "endLine": 92,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:92'"
                            },
                            "snippet": {
                              "text": "\t    db.Query(query)"
                            },
                            "startColumn": 15,
                            "startLine": 92
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a76f0507f5ad1fa2895cc324641352fe24fee68060ee39101409d5bab19ad8a8d596e1ee59e69f7579f191af64a91b0d9c9491373b0dd3302156e653e0a317e9_3"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 20,
                  "endLine": 92,
                  "snippet": {
                    "text": "\t    db.Query(query)"
                  },
                  "startColumn": 15,
                  "startLine": 92
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "8028a55826aec7f701942e6976eaea85908b9ec578b4e71cdc54dc10a2b1c743314e4136fb1e5738a49ed278c0c7e184adbb5974713c62800e4ac5994f7f3244_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 59,
                  "endLine": 112,
                  "snippet": {
                    "text": "    query := \"SELECT name FROM users WHERE email=\" + email"
                  },
                  "startColumn": 5,
                  "startLine": 112
                }
              }
            }
          ],
          "message": {
            "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.database.string-formatted-query.string-formatted-query"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d7e6c56c89a0008dd38196f7451d60decea3352dc8309cd58d2ad1dd6b66006533699e20e0957d4beca941e1d225589dd8b355e5762ce241f4b0601b5f40cc05_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 17,
                  "endLine": 114,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 2,
                  "startLine": 114
                }
              }
            }
          ],
          "message": {
            "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
          },
          "properties": {},
          "ruleId": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:114"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 2,
                            "endLine": 115,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:114'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 114,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:114'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 114
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "0a964f0a6bfe9b8cb134fab8040e946e84705bd6d838e58ac525fc85a854dba6ecec1f1c36064ea113b89ee9a190e884661c42dc040ac8b741a685da63cc6653_4"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 114,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 114
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
        },
        {
          "codeFlows": [
            {
              "message": {
                "text": "Untrusted dataflow from go/gorilla-go-vanillasql-format-string-sqli-taint.go:3 to go/gorilla-go-vanillasql-format-string-sqli-taint.go:114"
              },
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "message": {
                          "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 2,
                            "endLine": 115,
                            "message": {
                              "text": "Source: 'import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:3'"
                            },
                            "snippet": {
                              "text": "import (\n    \"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"database/sql\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/gorilla/schema\"\n    \"github.com/gorilla/rpc\"\n    \"github.com/gorilla/securecookie\"\n    \"github.com/gorilla/sessions\"\n)\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}\n\n// gorilla/schema\nvar decoder = schema.NewDecoder()\n\ntype Person struct {\n    Name  string\n    Phone string\n}\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n    var person Person\n    err := decoder.Decode(&person, r.PostForm)\n\n\n\tquery := \"SELECT name FROM users WHERE age=\" + person.Name\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n\treturn nil\n}\n\n// Gorilla securecookie\n\nfunc ReadCookieHandler(w http.ResponseWriter, r *http.Request) {\n\n    // Hash keys should be at least 32 bytes long\n    var hashKey = []byte(\"very-secret\")\n    // Block keys should be 16 bytes (AES-128) or 32 bytes (AES-256) long.\n    // Shorter keys may weaken the encryption used.\n    var blockKey = []byte(\"a-lot-secret\")\n    var s = securecookie.New(hashKey, blockKey)\n\n\tif cookie, err := r.Cookie(\"cookie-name\"); err == nil {\n\n\t\tvalue := make(map[string]string)\n\t\terr = s.Decode(\"cookie-name\", cookie.Value, &value);\n\n\t    db, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n        query := \"SELECT name FROM users WHERE age=\" + value[\"query\"]\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n        var cookies = map[string]*securecookie.SecureCookie{\n\t        \"previous\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n\t        \"current\": securecookie.New(\n\t        \tsecurecookie.GenerateRandomKey(64),\n\t        \tsecurecookie.GenerateRandomKey(32),\n\t        ),\n        }\n\n        err = securecookie.DecodeMulti(\"cookie-name\", cookie.Value, &value, cookies[\"current\"], cookies[\"previous\"])\n\t    db, err = sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n\n\t    // ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\t    db.Query(query)\n\n\t}\n}\n\n// gorilla sessions\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t// Get a session. Get() always returns a session, even if empty.\n\tsession, err := store.Get(r, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n    email := session.Values[\"email\"]\n\n\tdb, err := sql.Open(\"mysql\", \"theUser:thePassword@/theDbName\")\n    query := \"SELECT name FROM users WHERE email=\" + email\n\t// ruleid: gorilla-go-vanillasql-format-string-sqli-taint\n\tdb.Query(query)\n}"
                            },
                            "startColumn": 1,
                            "startLine": 3
                          }
                        }
                      },
                      "nestingLevel": 0
                    },
                    {
                      "location": {
                        "message": {
                          "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:114'"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go"
                          },
                          "region": {
                            "endColumn": 16,
                            "endLine": 114,
                            "message": {
                              "text": "Sink: 'db.Query(query)' @ 'go/gorilla-go-vanillasql-format-string-sqli-taint.go:114'"
                            },
                            "snippet": {
                              "text": "\tdb.Query(query)"
                            },
                            "startColumn": 11,
                            "startLine": 114
                          }
                        }
                      },
                      "nestingLevel": 1
                    }
                  ]
                }
              ]
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a76f0507f5ad1fa2895cc324641352fe24fee68060ee39101409d5bab19ad8a8d596e1ee59e69f7579f191af64a91b0d9c9491373b0dd3302156e653e0a317e9_4"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "go/gorilla-go-vanillasql-format-string-sqli-taint.go",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 16,
                  "endLine": 114,
                  "snippet": {
                    "text": "\tdb.Query(query)"
                  },
                  "startColumn": 11,
                  "startLine": 114
                }
              }
            }
          ],
          "message": {
            "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
          },
          "properties": {},
          "ruleId": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
        }
      ],
      "tool": {
        "driver": {
          "name": "Semgrep PRO",
          "rules": [
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
              },
              "help": {
                "markdown": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n - [https://pkg.go.dev/os/exec](https://pkg.go.dev/os/exec)\n - [https://pkg.go.dev/syscall#Exec](https://pkg.go.dev/syscall#Exec)\n - [https://semgrep.dev/docs/cheat-sheets/go-command-injection/](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)\n",
                "text": "Untrusted input might be injected into a command executed by the application, which can lead to a command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining complete control of the system. To prevent this vulnerability, avoid executing OS commands with user input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing the commands. In Go, it is possible to use the `exec.Command` function in combination with the `bash -c` command to run the user input as a shell command. To sanitize the user input, you can use a library like `shellescape` to escape any special characters before constructing the command. For more information, see: [Go command injection prevention](https://semgrep.dev/docs/cheat-sheets/go-command-injection/)"
              },
              "helpUri": "https://semgrep.dev/r/go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint",
              "id": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint",
              "name": "go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
                  "HIGH CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.gorilla.command-injection.gorilla-command-injection-taint.gorilla-command-injection-taint"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Detected non-static command inside Write. Audit the input to '$CW.Write'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "help": {
                "markdown": "Detected non-static command inside Write. Audit the input to '$CW.Write'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.lang.security.audit.dangerous-command-write.dangerous-command-write)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "Detected non-static command inside Write. Audit the input to '$CW.Write'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "helpUri": "https://semgrep.dev/r/go.lang.security.audit.dangerous-command-write.dangerous-command-write",
              "id": "go.lang.security.audit.dangerous-command-write.dangerous-command-write",
              "name": "go.lang.security.audit.dangerous-command-write.dangerous-command-write",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
                  "LOW CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.lang.security.audit.dangerous-command-write.dangerous-command-write"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
              },
              "help": {
                "markdown": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.lang.security.audit.sqli.gosql-sqli.gosql-sqli)\n - [https://golang.org/pkg/database/sql/](https://golang.org/pkg/database/sql/)\n",
                "text": "Detected string concatenation with a non-literal variable in a \"database/sql\" Go SQL statement. This could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order to prevent SQL injection, use parameterized queries or prepared statements instead. You can use prepared statements with the 'Prepare' and 'PrepareContext' calls."
              },
              "helpUri": "https://semgrep.dev/r/go.lang.security.audit.sqli.gosql-sqli.gosql-sqli",
              "id": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli",
              "name": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
                  "LOW CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.lang.security.audit.sqli.gosql-sqli.gosql-sqli"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The Origin header in the HTTP WebSocket handshake is used to guarantee that the connection accepted by the WebSocket is from a trusted origin domain. Failure to enforce can lead to Cross Site Request Forgery (CSRF). As per \"gorilla/websocket\" documentation: \"A CheckOrigin function should carefully validate the request origin to prevent cross-site request forgery.\""
              },
              "help": {
                "markdown": "The Origin header in the HTTP WebSocket handshake is used to guarantee that the connection accepted by the WebSocket is from a trusted origin domain. Failure to enforce can lead to Cross Site Request Forgery (CSRF). As per \"gorilla/websocket\" documentation: \"A CheckOrigin function should carefully validate the request origin to prevent cross-site request forgery.\"\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check)\n - [https://pkg.go.dev/github.com/gorilla/websocket#Upgrader](https://pkg.go.dev/github.com/gorilla/websocket#Upgrader)\n",
                "text": "The Origin header in the HTTP WebSocket handshake is used to guarantee that the connection accepted by the WebSocket is from a trusted origin domain. Failure to enforce can lead to Cross Site Request Forgery (CSRF). As per \"gorilla/websocket\" documentation: \"A CheckOrigin function should carefully validate the request origin to prevent cross-site request forgery.\""
              },
              "helpUri": "https://semgrep.dev/r/go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check",
              "id": "go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check",
              "name": "go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-352: Cross-Site Request Forgery (CSRF)",
                  "MEDIUM CONFIDENCE",
                  "OWASP-A01:2021 - Broken Access Control",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "help": {
                "markdown": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "Detected non-static command inside exec.Cmd. Audit the input to 'exec.Cmd'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "helpUri": "https://semgrep.dev/r/go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd",
              "id": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd",
              "name": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-94: Improper Control of Generation of Code ('Code Injection')",
                  "MEDIUM CONFIDENCE",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
              },
              "help": {
                "markdown": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements).\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint)\n - [https://golang.org/pkg/database/sql/](https://golang.org/pkg/database/sql/)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
              },
              "helpUri": "https://semgrep.dev/r/go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint",
              "id": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint",
              "name": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
                  "HIGH CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint.gorilla-go-vanillasql-format-string-sqli-taint"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "help": {
                "markdown": "Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified user data can reach this call site, this is a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary code."
              },
              "helpUri": "https://semgrep.dev/r/go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec",
              "id": "go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec",
              "name": "go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-94: Improper Control of Generation of Code ('Code Injection')",
                  "LOW CONFIDENCE",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
              },
              "help": {
                "markdown": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements).\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf)\n - [https://golang.org/pkg/database/sql/](https://golang.org/pkg/database/sql/)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "Untrusted input might be used to build a database query, which can lead to a SQL injection vulnerability. An attacker can execute malicious SQL statements and gain unauthorized access to sensitive data, modify, delete data, or execute arbitrary system commands. To prevent this vulnerability, use prepared statements that do not concatenate user-controllable strings and use parameterized queries where SQL commands and user data are strictly separated. Also, consider using an object-relational (ORM) framework to operate with safer abstractions. When building SQL queries in Go, it is possible to adopt prepared statements by using the `Prepare` and `PrepareContext` calls with parameterized queries. For more information, see: [Prepared statements in Go](https://go.dev/doc/database/prepared-statements)."
              },
              "helpUri": "https://semgrep.dev/r/go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf",
              "id": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf",
              "name": "go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
                  "MEDIUM CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.gorilla.sql.gorilla-go-vanillasql-format-string-sqli-taint-med-conf.gorilla-go-vanillasql-format-string-sqli-taint-med-conf"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
              },
              "help": {
                "markdown": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/go.lang.security.audit.database.string-formatted-query.string-formatted-query)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n",
                "text": "String-formatted SQL query detected. This could lead to SQL injection if the string is not sanitized properly. Audit this call to ensure the SQL is not manipulable by external data."
              },
              "helpUri": "https://semgrep.dev/r/go.lang.security.audit.database.string-formatted-query.string-formatted-query",
              "id": "go.lang.security.audit.database.string-formatted-query.string-formatted-query",
              "name": "go.lang.security.audit.database.string-formatted-query.string-formatted-query",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
                  "LOW CONFIDENCE",
                  "OWASP-A01:2017 - Injection",
                  "OWASP-A03:2021 - Injection",
                  "rule-board-audit",
                  "security"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: go.lang.security.audit.database.string-formatted-query.string-formatted-query"
              }
            }
          ],
          "semanticVersion": "1.96.0"
        }
      }
    }
  ],
  "version": "2.1.0"
}